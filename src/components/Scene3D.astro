---
import { THEME_TRANSITION_DURATION } from '../utils/theme';

interface Props {
  shapeCount?: number;
  complexity?: number;
  theme?: 'dark' | 'light';
}

const { 
  shapeCount = 30, 
  complexity = 0.7,
  theme = 'dark'
} = Astro.props;
---
<canvas id="bg" class="scene-3d"></canvas>

<script define:vars={{ shapeCount, complexity, theme, THEME_TRANSITION_DURATION }}>
  import * as THREE from 'three';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
  import { gsap } from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';

  class ProfessionalScene {
    constructor(initialTheme) {
      this.currentTheme = initialTheme;
      this.initScene();
      this.createShapes();
      this.setupLighting();
      this.setupPostProcessing();
      this.setupScrollEffects();
      this.animate();
      this.setupEventListeners();
    }

    initScene() {
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      this.renderer = new THREE.WebGLRenderer({ 
        canvas: document.querySelector('#bg'),
        alpha: true, 
        antialias: true 
      });

      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.camera.position.set(0, 0, 50);

      // Initial background update (if distinct from CSS)
      // this.updateSceneBackground(); 
    }

    updateSceneBackground() {
      // Handled by CSS/Canvas transparency for global parallax
    }

    createShapes() {
      this.shapes = [];
      const geometries = [
        new THREE.IcosahedronGeometry(2, Math.floor(complexity * 3)),
        new THREE.OctahedronGeometry(2, Math.floor(complexity * 3)),
        new THREE.TetrahedronGeometry(2, Math.floor(complexity * 3))
      ];

      const darkColors = [0xD4AF37, 0xC0C0C0, 0x708090];
      const lightColors = [0x007BFF, 0x6C757D, 0x28A745];

      const colors = this.currentTheme === 'dark' ? darkColors : lightColors;

      for (let i = 0; i < shapeCount; i++) {
        const geometry = geometries[Math.floor(Math.random() * geometries.length)];
        const material = new THREE.MeshPhongMaterial({
          color: colors[Math.floor(Math.random() * colors.length)],
          wireframe: Math.random() > 0.5,
          transparent: true,
          opacity: 0.6 * complexity
        });

        const shape = new THREE.Mesh(geometry, material);
        
        shape.position.set(
          (Math.random() - 0.5) * 100,
          (Math.random() - 0.5) * 100,
          (Math.random() - 0.5) * 100
        );
        
        // Random scale for variety
        const scale = Math.random() * 1.5 + 0.5;
        shape.scale.set(scale, scale, scale);

        this.scene.add(shape);
        this.shapes.push(shape);

        this.animateShape(shape);
      }
    }

    animateShape(shape) {
      gsap.to(shape.rotation, {
        x: `+=${Math.random() * 2}`,
        y: `+=${Math.random() * 2}`,
        z: `+=${Math.random() * 2}`,
        duration: 5 + Math.random() * 5,
        repeat: -1,
        yoyo: true,
        ease: 'power1.inOut'
      });
    }

    setupLighting() {
      this.ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
      this.directionalLight = new THREE.DirectionalLight(
        this.currentTheme === 'dark' ? 0xD4AF37 : 0x007BFF, 
        0.6
      );
      this.directionalLight.position.set(5, 5, 5);

      this.scene.add(this.ambientLight, this.directionalLight);
    }

    setupPostProcessing() {
      this.composer = new EffectComposer(this.renderer);
      const renderPass = new RenderPass(this.scene, this.camera);
      this.composer.addPass(renderPass);

      const bloomPass = new UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight),
        0.4,  // strength
        0.3,  // radius
        0.75  // threshold
      );
      this.composer.addPass(bloomPass);
    }

    setupScrollEffects() {
      gsap.registerPlugin(ScrollTrigger);

      // Rotate the entire scene for parallax effect
      gsap.to(this.scene.rotation, {
        y: Math.PI * 0.5, 
        x: Math.PI * 0.1,
        scrollTrigger: {
          trigger: "body",
          start: "top top",
          end: "bottom bottom",
          scrub: 1
        }
      });

      // Move camera slightly for depth
      gsap.to(this.camera.position, {
        z: 40,
        scrollTrigger: {
          trigger: "body",
          start: "top top",
          end: "bottom bottom",
          scrub: 1.5
        }
      });
      
      // Dynamic Lighting Color Shift
      // Deep Space Blue -> Cyber Purple -> Midday Gold (Cycle)
      if (this.currentTheme === 'dark') {
          const tl = gsap.timeline({
            scrollTrigger: {
                trigger: "body",
                start: "top top",
                end: "bottom bottom",
                scrub: true
            }
          });
          
          tl.to(this.directionalLight.color, { r: 0.5, g: 0.0, b: 0.5 }) // Purple
            .to(this.directionalLight.color, { r: 0.0, g: 0.5, b: 0.8 }); // Cyan
      }
    }

    animate() {
      requestAnimationFrame(() => this.animate());
      this.composer.render();
    }

    setupEventListeners() {
      window.addEventListener('resize', () => {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.composer.setSize(window.innerWidth, window.innerHeight);
      });

      document.addEventListener('theme-changed', (event) => {
        const newTheme = event.detail.theme;
        if (this.currentTheme !== newTheme) {
          this.currentTheme = newTheme;
          // lighter re-init for theme change
          this.setupLighting();
          // Update colors of existing shapes instead of full recreate (optional optimization)
          const newColors = newTheme === 'dark' ? 
            [0xD4AF37, 0xC0C0C0, 0x708090] : 
            [0x007BFF, 0x6C757D, 0x28A745];
            
          this.shapes.forEach(shape => {
              shape.material.color.setHex(newColors[Math.floor(Math.random() * newColors.length)]);
          });
        }
      });
    }
  }

  new ProfessionalScene(theme);
</script>

<style define:vars={{ THEME_TRANSITION_DURATION }}>
  .scene-3d {
    position: fixed;
    top: 0;
    left: 0;
    z-index: -1;
    width: 100%;
    height: 100%;
    opacity: 0.7;
    background: linear-gradient(
      45deg, 
      color-mix(in srgb, var(--bg-primary) 10%, transparent), 
      color-mix(in srgb, var(--bg-secondary) 10%, transparent)
    );
    transition: background var(--THEME_TRANSITION_DURATION) ease;
  }
</style>
