---
import { UX_CONFIG } from '../utils/ux';

interface SkillNode {
    id: string;
    group: number;
    value: number;
    icon?: string;
    description?: string;
}

interface SkillLink {
    source: string;
    target: string;
    value: number;
}

// Data transformation for force graph
const skillsData = {
    nodes: [        
        // Groups: 1=AI, 2=Data, 3=Web, 4=Core
        { id: "Digital Architect", group: 4, value: 20, icon: "ðŸ‘‘" },
        
        // AI & ML
        { id: "AI & ML", group: 1, value: 15, icon: "ðŸ¤–" },
        { id: "TensorFlow", group: 1, value: 10 },
        { id: "PyTorch", group: 1, value: 10 },
        { id: "Scikit-learn", group: 1, value: 8 },
        { id: "LLMs", group: 1, value: 12 },
        { id: "OpenAI API", group: 1, value: 9 },
        
        // Data Science
        { id: "Data Science", group: 2, value: 15, icon: "ðŸ“Š" },
        { id: "Pandas", group: 2, value: 10 },
        { id: "NumPy", group: 2, value: 10 },
        { id: "Python", group: 2, value: 12 },
        { id: "SQL", group: 2, value: 9 },
        
        // Web Tech
        { id: "Web Tech", group: 3, value: 15, icon: "ðŸ’»" },
        { id: "React", group: 3, value: 12 },
        { id: "TypeScript", group: 3, value: 11 },
        { id: "Node.js", group: 3, value: 11 },
        { id: "Astro", group: 3, value: 9 },
        { id: "Next.js", group: 3, value: 10 },
        { id: "GraphQL", group: 3, value: 8 }
    ],
    links: [
        { source: "Digital Architect", target: "AI & ML", value: 5 },
        { source: "Digital Architect", target: "Data Science", value: 5 },
        { source: "Digital Architect", target: "Web Tech", value: 5 },
        
        { source: "AI & ML", target: "TensorFlow", value: 3 },
        { source: "AI & ML", target: "PyTorch", value: 3 },
        { source: "AI & ML", target: "Scikit-learn", value: 3 },
        { source: "AI & ML", target: "LLMs", value: 4 },
        { source: "AI & ML", target: "OpenAI API", value: 3 },
        { source: "TensorFlow", target: "Python", value: 2 },
        { source: "PyTorch", target: "Python", value: 2 },
        
        { source: "Data Science", target: "Pandas", value: 3 },
        { source: "Data Science", target: "NumPy", value: 3 },
        { source: "Data Science", target: "Python", value: 4 },
        { source: "Data Science", target: "SQL", value: 3 },
        
        { source: "Web Tech", target: "React", value: 3 },
        { source: "Web Tech", target: "TypeScript", value: 3 },
        { source: "Web Tech", target: "Node.js", value: 3 },
        { source: "Web Tech", target: "Astro", value: 3 },
        { source: "Web Tech", target: "Next.js", value: 3 },
        { source: "Web Tech", target: "GraphQL", value: 2 },
        { source: "React", target: "TypeScript", value: 2 },
        { source: "Next.js", target: "React", value: 2 },
        { source: "Node.js", target: "TypeScript", value: 2 }
    ]
};
---

<section id="skills" class="skills-visualization-section">
    <div class="skills-header">
        <h2 class="section-title">Technical Neural Network</h2>
        <p class="section-subtitle">Interactive Proficiency Map</p>
    </div>

    <div class="canvas-container theme-hover">
        <canvas id="skills-canvas"></canvas>
        <div class="overlay-instruction">
            <span>Drag nodes to explore â€¢ Scroll to zoom</span>
        </div>
        <div id="tooltip" class="skill-tooltip"></div>
    </div>
</section>

<script>
    import * as d3 from 'd3';

    // Type definitions for D3 nodes and links
    interface Node extends d3.SimulationNodeDatum {
        id: string;
        group: number;
        value: number;
        icon?: string;
    }

    interface Link extends d3.SimulationLinkDatum<Node> {
        source: string | Node;
        target: string | Node;
        value: number;
    }

    const canvas = document.getElementById('skills-canvas') as HTMLCanvasElement;
    const container = canvas.parentElement;
    const tooltip = document.getElementById('tooltip');
    
    // Check if container exists before proceeding
    if (container) {
        let width = container.clientWidth;
        let height = 600;
        
        // Set canvas resolution for retina displays
        const scale = window.devicePixelRatio || 1;
        canvas.width = width * scale;
        canvas.height = height * scale;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
        
        const context = canvas.getContext('2d');
        if (context) context.scale(scale, scale);

        // Color scales
        const colorScale = d3.scaleOrdinal<string>()
            .domain(['1', '2', '3', '4'])
            .range(['#FF6B6B', '#4ECDC4', '#45B7D1', '#D4AF37']);

        // @ts-ignore - Data comes from Astro frontmatter which is effectively global here or passed as json
        // We'll reconstruct the data here for the script to use directly to avoid serializing issues
        const nodes: Node[] = [
            { id: "Digital Architect", group: 4, value: 20, icon: "ðŸ‘‘" },
            { id: "AI & ML", group: 1, value: 15, icon: "ðŸ¤–" },
            { id: "TensorFlow", group: 1, value: 10 },
            { id: "PyTorch", group: 1, value: 10 },
            { id: "Scikit-learn", group: 1, value: 8 },
            { id: "LLMs", group: 1, value: 12 },
            { id: "OpenAI", group: 1, value: 9 },
            { id: "Data Science", group: 2, value: 15, icon: "ðŸ“Š" },
            { id: "Pandas", group: 2, value: 10 },
            { id: "NumPy", group: 2, value: 10 },
            { id: "Python", group: 2, value: 12 },
            { id: "SQL", group: 2, value: 9 },
            { id: "Web Tech", group: 3, value: 15, icon: "ðŸ’»" },
            { id: "React", group: 3, value: 12 },
            { id: "TypeScript", group: 3, value: 11 },
            { id: "Node.js", group: 3, value: 11 },
            { id: "Astro", group: 3, value: 9 },
            { id: "Next.js", group: 3, value: 10 },
            { id: "GraphQL", group: 3, value: 8 }
        ].map(d => ({...d})); // Clone to avoid mutation issues if re-run

        const links: Link[] = [
            { source: "Digital Architect", target: "AI & ML", value: 5 },
            { source: "Digital Architect", target: "Data Science", value: 5 },
            { source: "Digital Architect", target: "Web Tech", value: 5 },
            { source: "AI & ML", target: "TensorFlow", value: 3 },
            { source: "AI & ML", target: "PyTorch", value: 3 },
            { source: "AI & ML", target: "Scikit-learn", value: 3 },
            { source: "AI & ML", target: "LLMs", value: 4 },
            { source: "AI & ML", target: "OpenAI", value: 3 },
            { source: "TensorFlow", target: "Python", value: 2 },
            { source: "PyTorch", target: "Python", value: 2 },
            { source: "Data Science", target: "Pandas", value: 3 },
            { source: "Data Science", target: "NumPy", value: 3 },
            { source: "Data Science", target: "Python", value: 4 },
            { source: "Data Science", target: "SQL", value: 3 },
            { source: "Web Tech", target: "React", value: 3 },
            { source: "Web Tech", target: "TypeScript", value: 3 },
            { source: "Web Tech", target: "Node.js", value: 3 },
            { source: "Web Tech", target: "Astro", value: 3 },
            { source: "Web Tech", target: "Next.js", value: 3 },
            { source: "Web Tech", target: "GraphQL", value: 2 },
            { source: "React", target: "TypeScript", value: 2 },
            { source: "Next.js", target: "React", value: 2 },
            { source: "Node.js", target: "TypeScript", value: 2 }
        ].map(d => ({...d}));

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id((d: any) => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide().radius((d: any) => d.value * 2 + 5));

        // Drag functions
        const drag = (simulation: any) => {
            function dragstarted(event: any) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
                canvas.style.cursor = 'grabbing';
            }
            
            function dragged(event: any) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            
            function dragended(event: any) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
                canvas.style.cursor = 'grab';
            }
            
            return d3.drag()
                .subject((event) => {
                    const [x, y] = [event.x, event.y];
                    // Find node closest to pointer
                    let subject = null;
                    let distance = Infinity;
                    for (const node of nodes) {
                        const dist = Math.sqrt((x - node.x!) ** 2 + (y - node.y!) ** 2);
                        if (dist < distance && dist < 30) {
                            distance = dist;
                            subject = node;
                        }
                    }
                    return subject;
                })
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        };

        // Attach drag handler
        d3.select(canvas).call(drag(simulation) as any);

        // Interaction state
        let hoverNode: any = null;

        d3.select(canvas).on("mousemove", (event) => {
            const [mouseX, mouseY] = d3.pointer(event);
            
            // Find hover node
            let prevHover = hoverNode;
            hoverNode = null;
            let minDist = Infinity;
            
            for (const node of nodes) {
                const dist = Math.sqrt((mouseX - node.x!) ** 2 + (mouseY - node.y!) ** 2);
                if (dist < node.value * 2 + 5) { // Hit radius
                    hoverNode = node;
                    break;
                }
            }

            if (hoverNode !== prevHover) {
                canvas.style.cursor = hoverNode ? 'pointer' : 'default';
                
                // Show/hide tooltip
                if (hoverNode && tooltip) {
                    tooltip.style.opacity = '1';
                    tooltip.innerHTML = `<strong>${hoverNode.id}</strong>`;
                    tooltip.style.left = `${event.pageX + 10}px`;
                    tooltip.style.top = `${event.pageY - 10}px`;
                } else if (tooltip) {
                    tooltip.style.opacity = '0';
                }
            }
            
            if (hoverNode) restart();
        });

        // Loop animation
        function restart() {
            if (!context) return;
            context.clearRect(0, 0, width, height);
            
            // Draw links
            context.save();
            context.globalAlpha = 0.2;
            context.strokeStyle = "#999";
            context.beginPath();
            links.forEach((link: any) => {
                context.moveTo(link.source.x, link.source.y);
                context.lineTo(link.target.x, link.target.y);
            });
            context.stroke();
            context.restore();

            // Draw link highlights (if hover)
            if (hoverNode) {
                context.save();
                context.strokeStyle = "#fff";
                context.globalAlpha = 0.6;
                context.lineWidth = 1.5;
                context.beginPath();
                links.forEach((link: any) => {
                    if (link.source.id === hoverNode.id || link.target.id === hoverNode.id) {
                        context.moveTo(link.source.x, link.source.y);
                        context.lineTo(link.target.x, link.target.y);
                    }
                });
                context.stroke();
                context.restore();
            }

            // Draw nodes
            nodes.forEach((node: any) => {
                context.beginPath();
                const radius = node.value * 1.5;
                const isHovered = hoverNode === node;
                const isConnected = hoverNode && links.some((l: any) => 
                    (l.source.id === hoverNode.id && l.target.id === node.id) ||
                    (l.target.id === hoverNode.id && l.source.id === node.id)
                );

                // Pulse effect
                const pulse = Math.sin(Date.now() / 1000 + node.index!) * 1.5;
                
                context.arc(node.x, node.y, isHovered ? radius + 5 : radius + pulse, 0, 2 * Math.PI);
                context.fillStyle = colorScale(String(node.group));
                
                if (isHovered) {
                    context.shadowBlur = 20;
                    context.shadowColor = colorScale(String(node.group));
                } else if (isConnected) {
                    context.shadowBlur = 10;
                    context.shadowColor = colorScale(String(node.group));
                } else {
                    context.shadowBlur = 0;
                }
                
                context.fill();
                context.strokeStyle = "#1a1a1a";
                context.lineWidth = 2;
                context.stroke();

                // Draw icon or text
                context.fillStyle = "#fff";
                context.font = `${isHovered ? 'bold ' : ''}12px Inter`;
                context.textAlign = "center";
                context.textBaseline = "middle";
                
                // Show text if large node or hovered/connected
                if (node.value > 12 || isHovered || isConnected) {
                    context.fillText(node.id, node.x, node.y + radius + 15);
                }
                
                if (node.icon) {
                     context.font = "16px Arial";
                     context.fillText(node.icon, node.x, node.y);
                }
            });
        }

        d3.timer(restart);

        // Handle resize
        window.addEventListener('resize', () => {
             // Re-measuring container width would require logic here
             // specific to resizing the canvas and simulation center
        });
    }
</script>

<style define:vars={{
     transitionDuration: `${UX_CONFIG.TRANSITION_DURATION}ms`
}}>
    .skills-visualization-section {
        max-width: 1200px;
        margin: 4rem auto;
        padding: 2rem;
        background: color-mix(in srgb, var(--bg-primary) 80%, transparent);
        border-radius: 16px;
        border: 1px solid color-mix(in srgb, var(--accent) 20%, transparent);
        transition: background-color var(--transitionDuration) ease;
    }

    .skills-header {
        text-align: center;
        margin-bottom: 2rem;
        position: relative;
        z-index: 2;
    }

    .section-title {
        font-size: 2.5rem;
        color: var(--primary);
        margin: 0;
        font-family: 'Orbitron', sans-serif;
    }

    .canvas-container {
        position: relative;
        width: 100%;
        height: 600px;
        background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        border-radius: 12px;
        overflow: hidden;
        box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
        cursor: grab;
    }

    .canvas-container:active {
        cursor: grabbing;
    }

    .overlay-instruction {
        position: absolute;
        bottom: 1rem;
        left: 50%;
        transform: translateX(-50%);
        color: rgba(255,255,255,0.5);
        font-size: 0.8rem;
        pointer-events: none;
    }

    .skill-tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 10;
        backdrop-filter: blur(4px);
        border: 1px solid rgba(255,255,255,0.2);
    }
</style>
